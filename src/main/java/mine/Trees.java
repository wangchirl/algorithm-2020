package mine;

/**
 * @author shadow
 * @create 2020-12-06
 * @description
 */
public class Trees {
	public static void main(String[] args) {

	}

	// 16、给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离

	// 15、给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先

	// 14、给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树

	// 13、给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点


	// 12、给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小


	// 11、给定一颗二叉树的头结点，返回这颗二叉树是否搜索二叉树


	// 10、给定一颗二叉树的头结点，返回这颗二叉树是否满二叉树


	// 9、给定一颗二叉树的头结点，返回这颗二叉树是否平衡二叉树


	// 8、折纸问题
	/**
	 * 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，
	 * 压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。
	 * 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。
	 * 给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。
	 * 例如:N=1时，打印: down N=2时，打印: down down up
	 */

	// 7、给你二叉树中的某个节点，返回该节点的后继节点

	// 6、求二叉树最宽的层有多少个结点

	// 5、二叉树的序列化与反序列化
	/**
	 * 1）可以用先序或者中序或者后序或者按层遍历，来实现二叉树的序列化
	 *
	 * 2）用了什么方式序列化，就用什么样的方式反序列化
	 */


	// 4、二叉树的层次遍历 - 队列
	/**
	 * 1）其实就是宽度优先遍历，用队列
	 *
	 * 2）可以通过设置flag变量的方式，来发现某一层的结束（看题目）
	 */

	/**
	 * 先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树
	 *
	 * 中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树
	 *
	 * 后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点
	 *
	 * 1）理解递归序
	 *
	 * 2）先序、中序、后序都可以在递归序的基础上加工出来
	 *
	 * 3）第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序
	 *
	 * 1）任何递归函数都可以改成非递归
	 *
	 * 2）自己设计压栈的来实现
	 */
	// 3、二叉树的后序遍历

	// 2、二叉树的中序遍历

	// 1、二叉树的先序遍历

}
